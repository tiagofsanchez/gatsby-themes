{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["default","sift","require","prepareRegex","makeRe","objectToDottedField","createDbQueriesFromObject","prefixResolvedFields","dbQueryToSiftQuery","ensureIndexByQuery","ensureIndexByElemMatch","getNodesFromCacheByValue","addResolvedNodes","getNode","siftGetNode","FAST_OPS","lastFilterUsedSift","createFilterCacheKey","typeNames","filter","f","comparator","paths","push","path","type","q","nestedQuery","query","join","prepareQueryArgs","filterFields","Object","keys","reduce","acc","key","value","_","isPlainObject","isEqId","siftArgs","length","id","handleFirst","nodes","index","isEmpty","findIndex","$and","handleMany","result","runFiltersWithoutSift","filters","nodeTypeNames","filtersCache","nodesPerValueSets","getBucketsForFilters","undefined","sort","a","b","size","needles","pop","forEach","node","every","cache","has","filterCacheKey","getBucketsForQueryFilter","collectBucketForElemMatch","filterPath","filterValue","nodesPerValue","targetValue","includes","nodesByValue","runFilterAndSort","args","queryArgs","resolvedFields","firstOnly","stats","applyFilters","sortNodes","exports","runSift","didLastFilterUseSift","_didLastFilterUseSift","filterStats","filterToStats","comparatorPath","comparatorsUsed","set","get","uniqueFilterPaths","add","totalNonSingleFilters","filterWithoutSift","totalIndexHits","slice","siftResult","filterWithSift","totalSiftHits","concat","some","typeName","runSiftOnNodes","map","$eq","internal","dottedFields","dottedFieldKeys","sortFields","fields","field","startsWith","sortFns","v","sortOrder","order","toLowerCase","sortField","uniqueSorts","orderBy"],"mappings":"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","sourcesContent":["// @flow\n\nconst { default: sift } = require(`sift`)\nconst { prepareRegex } = require(`../utils/prepare-regex`)\nconst { makeRe } = require(`micromatch`)\nimport { getValueAt } from \"../utils/get-value-at\"\nimport _ from \"lodash\"\nconst {\n  objectToDottedField,\n  createDbQueriesFromObject,\n  prefixResolvedFields,\n  dbQueryToSiftQuery,\n} = require(`../db/common/query`)\nconst {\n  ensureIndexByQuery,\n  ensureIndexByElemMatch,\n  getNodesFromCacheByValue,\n  addResolvedNodes,\n  getNode: siftGetNode,\n} = require(`./nodes`)\n\nconst FAST_OPS = [\n  `$eq`,\n  `$ne`,\n  `$lt`,\n  `$lte`,\n  `$gt`,\n  `$gte`,\n  `$in`,\n  `$nin`,\n  `$regex`, // Note: this includes $glob\n]\n\n// More of a testing mechanic, to verify whether last runSift call used Sift\nlet lastFilterUsedSift = false\n\n/**\n * Creates a key for one filterCache inside FiltersCache\n *\n * @param {Array<string>} typeNames\n * @param {DbQuery} filter\n * @returns {FilterCacheKey} (a string: `types.join()/path.join()/operator` )\n */\nconst createFilterCacheKey = (typeNames, filter) => {\n  // Note: while `elemMatch` is a special case, in the key it's just `elemMatch`\n  // (This function is future proof for elemMatch support, won't receive it yet)\n  let f = filter\n  let comparator = ``\n  let paths /*: Array<string>*/ = []\n  while (f) {\n    paths.push(...f.path)\n    if (f.type === `elemMatch`) {\n      let q /*: IDbQueryElemMatch*/ = f\n      f = q.nestedQuery\n      // Make distinction between filtering `a.elemMatch.b.eq` and `a.b.eq`\n      // In practice this is unlikely to be an issue, but it might\n      paths.push(`elemMatch`)\n    } else {\n      let q /*: IDbQueryQuery*/ = f\n      comparator = q.query.comparator\n      break\n    }\n  }\n\n  // Note: the separators (`,` and `/`) are arbitrary but must be different\n  return typeNames.join(`,`) + `/` + paths.join(`,`) + `/` + comparator\n}\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nconst prepareQueryArgs = (filterFields = {}) =>\n  Object.keys(filterFields).reduce((acc, key) => {\n    const value = filterFields[key]\n    if (_.isPlainObject(value)) {\n      acc[key === `elemMatch` ? `$elemMatch` : key] = prepareQueryArgs(value)\n    } else {\n      switch (key) {\n        case `regex`:\n          acc[`$regex`] = prepareRegex(value)\n          break\n        case `glob`:\n          acc[`$regex`] = makeRe(value)\n          break\n        default:\n          acc[`$${key}`] = value\n      }\n    }\n    return acc\n  }, {})\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(siftArgs) {\n  // The `id` of each node is invariably unique. So if a query is doing id $eq(string) it can find only one node tops\n  return (\n    siftArgs.length > 0 &&\n    siftArgs[0].id &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction handleFirst(siftArgs, nodes) {\n  if (nodes.length === 0) {\n    return []\n  }\n\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : nodes.findIndex(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : nodes.filter(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  return result?.length ? result : null\n}\n\n/**\n * Given the path of a set of filters, return the sets of nodes that pass the\n * filter.\n * Only nodes of given node types will be considered\n * A fast index is created if one doesn't exist yet so cold call is slower.\n * Returns undefined if an op was not supported for fast indexes or when no\n * nodes were found for given (query) value. In the zero nodes case, we have to\n * go through Sift to make sure we're not missing an edge case, for now.\n *\n * @param {Array<DbQuery>} filters Resolved. (Should be checked by caller to exist)\n * @param {Array<string>} nodeTypeNames\n * @param {FiltersCache} filtersCache\n * @returns {Array<IGatsbyNode> | undefined}\n */\nconst runFiltersWithoutSift = (filters, nodeTypeNames, filtersCache) => {\n  const nodesPerValueSets /*: Array<Set<IGatsbyNode>> */ = getBucketsForFilters(\n    filters,\n    nodeTypeNames,\n    filtersCache\n  )\n\n  if (!nodesPerValueSets) {\n    // Let Sift take over as fallback\n    return undefined\n  }\n\n  // Put smallest last (we'll pop it)\n  nodesPerValueSets.sort(\n    (a /*: Set<IGatsbyNode> */, b /*: Set<IGatsbyNode> */) => b.size - a.size\n  )\n  // Iterate on the set with the fewest elements and create the intersection\n  const needles /*: Set<IGatsbyNode>*/ = nodesPerValueSets.pop()\n  // Take the intersection of the retrieved caches-by-value\n  const result /*: Array<IGatsbyNode> */ = []\n\n  // This _can_ still be expensive but the set of nodes should be limited ...\n  needles.forEach((node /*: IGatsbyNode */) => {\n    if (\n      nodesPerValueSets.every((cache /*: Set<IGatsbyNode> */) =>\n        cache.has(node)\n      )\n    ) {\n      // Every cache set contained this node so keep it\n      result.push(node)\n    }\n  })\n\n  // TODO: do we cache this result? I'm not sure how likely it is to be reused\n  // Consider the case of {a: {eq: 5}, b: {eq: 10}}, do we cache the [5,10]\n  // case for all value pairs? How likely is that to ever be reused?\n\n  if (result.length === 0) {\n    return undefined\n  }\n  return result\n}\n\n/**\n * @param {Array<DbQuery>} filters\n * @param {Array<string>} nodeTypeNames\n * @param {FiltersCache} filtersCache\n * @returns {Array<Set<IGatsbyNode>> | undefined} Undefined means at least one\n *   cache was not found. Must fallback to sift.\n */\nconst getBucketsForFilters = (filters, nodeTypeNames, filtersCache) => {\n  const nodesPerValueSets /*: Array<Set<IGatsbyNode>>*/ = []\n\n  // Fail fast while trying to create and get the value-cache for each path\n  let every = filters.every((filter /*: DbQuery*/) => {\n    let filterCacheKey = createFilterCacheKey(nodeTypeNames, filter)\n    if (filter.type === `query`) {\n      // (Let TS warn us if a new query type gets added)\n      const q /*: IDbQueryQuery */ = filter\n      return getBucketsForQueryFilter(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueSets\n      )\n    } else {\n      // (Let TS warn us if a new query type gets added)\n      const q /*: IDbQueryElemMatch*/ = filter\n      return collectBucketForElemMatch(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueSets\n      )\n    }\n  })\n\n  if (every) {\n    return nodesPerValueSets\n  }\n\n  // \"failed at least one\"\n  return undefined\n}\n\n/**\n * Fetch all buckets for given query filter. That means it's not elemMatch.\n *\n * @param {FilterCacheKey} filterCacheKey\n * @param {IDbQueryQuery} filter\n * @param {Array<string>} nodeTypeNames\n * @param {FiltersCache} filtersCache\n * @param {Array<Set<IgatsbyNode>>} nodesPerValueSets\n * @returns {boolean} false means soft fail, filter must go through Sift\n */\nconst getBucketsForQueryFilter = (\n  filterCacheKey,\n  filter,\n  nodeTypeNames,\n  filtersCache,\n  nodesPerValueSets\n) => {\n  let {\n    path: filterPath,\n    query: {\n      // Note: comparator is verified to be a FilterOp in filterWithoutSift\n      comparator /*: as FilterOp*/,\n      value: filterValue,\n    },\n  } = filter\n\n  if (!filtersCache.has(filterCacheKey)) {\n    ensureIndexByQuery(\n      comparator,\n      filterCacheKey,\n      filterPath,\n      nodeTypeNames,\n      filtersCache\n    )\n  }\n\n  const nodesPerValue /*: Set<IGatsbyNode> | undefined */ = getNodesFromCacheByValue(\n    filterCacheKey,\n    filterValue,\n    filtersCache\n  )\n\n  // If we couldn't find the needle then maybe sift can, for example if the\n  // schema contained a proxy; `slug: String @proxy(from: \"slugInternal\")`\n  // There are also cases (and tests) where id exists with a different type\n  if (!nodesPerValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty Set because the indexing\n  // mechanism does not create a Set unless there's a IGatsbyNode for it\n  nodesPerValueSets.push(nodesPerValue)\n\n  return true\n}\n\n/**\n * @param {FilterCacheKey} filterCacheKey\n * @param {IDbQueryElemMatch} filter\n * @param {Array<string>} nodeTypeNames\n * @param {FiltersCache} filtersCache\n * @param {Array<Set<IGatsbyNode>>} nodesPerValueSets Matching node sets are put in this array\n */\nconst collectBucketForElemMatch = (\n  filterCacheKey,\n  filter,\n  nodeTypeNames,\n  filtersCache,\n  nodesPerValueSets\n) => {\n  // Get comparator and target value for this elemMatch\n  let comparator = ``\n  let targetValue = null\n  let f /*: DbQuery*/ = filter\n  while (f) {\n    if (f.type === `elemMatch`) {\n      const q /*: IDbQueryElemMatch */ = f\n      f = q.nestedQuery\n    } else {\n      const q /*: IDbQueryQuery */ = f\n      comparator = q.query.comparator\n      targetValue = q.query.value\n      break\n    }\n  }\n\n  if (!FAST_OPS.includes(comparator)) {\n    return false\n  }\n\n  if (!filtersCache.has(filterCacheKey)) {\n    ensureIndexByElemMatch(\n      comparator,\n      filterCacheKey,\n      filter,\n      nodeTypeNames,\n      filtersCache\n    )\n  }\n\n  const nodesByValue /*: Set<IGatsbyNode> | undefined*/ = getNodesFromCacheByValue(\n    filterCacheKey,\n    targetValue,\n    filtersCache\n  )\n\n  // If we couldn't find the needle then maybe sift can, for example if the\n  // schema contained a proxy; `slug: String @proxy(from: \"slugInternal\")`\n  // There are also cases (and tests) where id exists with a different type\n  if (!nodesByValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty Set because the indexing\n  // mechanism does not create a Set unless there's a IGatsbyNode for it\n  nodesPerValueSets.push(nodesByValue)\n\n  return true\n}\n\n/**\n * Filters and sorts a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter/sort as an object\n * @property {boolean} args.firstOnly true if you want to return only the first\n *   result found. This will return a collection of size 1. Not a single element\n * @property {{filter?: Object, sort?: Object} | undefined} args.queryArgs\n * @property {undefined | null | FiltersCache} args.filtersCache May be null or\n *   undefined. A cache of indexes where you can look up Nodes grouped by a\n *   FilterCacheKey, which yields a Map which holds a Set of Nodes for the value\n *   that the filter is trying to query against.\n *   This object lives in query/query-runner.js and is passed down runQuery.\n *   If it is undefined or null, do not consider to use a fast index at all.\n * @returns Collection of results. Collection will be limited to 1\n *   if `firstOnly` is true\n */\nconst runFilterAndSort = (args: Object) => {\n  const {\n    queryArgs: { filter, sort } = { filter: {}, sort: {} },\n    resolvedFields = {},\n    firstOnly = false,\n    nodeTypeNames,\n    filtersCache,\n    stats,\n  } = args\n\n  const result = applyFilters(\n    filter,\n    firstOnly,\n    nodeTypeNames,\n    filtersCache,\n    resolvedFields,\n    stats\n  )\n\n  return sortNodes(result, sort, resolvedFields, stats)\n}\n\nexports.runSift = runFilterAndSort\n\nexports.didLastFilterUseSift = function _didLastFilterUseSift() {\n  return lastFilterUsedSift\n}\n\n/**\n * Applies filter. First through a simple approach, which is much faster than\n * running sift, but not as versatile and correct. If no nodes were found then\n * it falls back to filtering through sift.\n *\n * @param {Array<DbQuery> | undefined} filterFields\n * @param {boolean} firstOnly\n * @param {Array<string>} nodeTypeNames\n * @param {undefined | null | FiltersCache} filtersCache\n * @param resolvedFields\n * @returns {Array<IGatsbyNode> | undefined} Collection of results. Collection\n *   will be limited to 1 if `firstOnly` is true\n */\nconst applyFilters = (\n  filterFields,\n  firstOnly,\n  nodeTypeNames,\n  filtersCache,\n  resolvedFields,\n  stats\n) => {\n  const filters /*: Array<DbQuery>*/ = filterFields\n    ? prefixResolvedFields(\n        createDbQueriesFromObject(prepareQueryArgs(filterFields)),\n        resolvedFields\n      )\n    : []\n\n  if (stats) {\n    filters.forEach((filter /*: DbQuery*/) => {\n      const filterStats = filterToStats(filter)\n      const comparatorPath = filterStats.comparatorPath.join(`.`)\n      stats.comparatorsUsed.set(\n        comparatorPath,\n        (stats.comparatorsUsed.get(comparatorPath) || 0) + 1\n      )\n      stats.uniqueFilterPaths.add(filterStats.filterPath.join(`.`))\n    })\n    if (filters.length > 1) {\n      stats.totalNonSingleFilters++\n    }\n  }\n\n  const result = filterWithoutSift(filters, nodeTypeNames, filtersCache)\n\n  lastFilterUsedSift = false\n  if (result) {\n    if (stats) {\n      stats.totalIndexHits++\n    }\n    if (firstOnly) {\n      return result.slice(0, 1)\n    }\n    return result\n  }\n  lastFilterUsedSift = true\n\n  const siftResult = filterWithSift(\n    filters,\n    firstOnly,\n    nodeTypeNames,\n    resolvedFields\n  )\n\n  if (stats) {\n    if (!siftResult || siftResult.length === 0) {\n      stats.totalSiftHits++\n    }\n  }\n\n  return siftResult\n}\n\nconst filterToStats = (\n  filter /*: DbQuery*/,\n  filterPath = [],\n  comparatorPath = []\n) => {\n  if (filter.type === `elemMatch`) {\n    return filterToStats(\n      filter.nestedQuery,\n      filterPath.concat(filter.path),\n      comparatorPath.concat([`elemMatch`])\n    )\n  } else {\n    return {\n      filterPath: filterPath.concat(filter.path),\n      comparatorPath: comparatorPath.concat(filter.query.comparator),\n    }\n  }\n}\n\n/**\n * Check if filter op is supported (not all are). If so, uses custom\n * fast indexes based on filter and types and returns any result it finds.\n * If conditions are not met or no nodes are found, returns undefined and\n * a slow run through Sift is executed instead.\n * This function is a noop if no filter cache is given to it.\n *\n * @param {Array<DbQuery>} filters Resolved. (Should be checked by caller to exist)\n * @param {Array<string>} nodeTypeNames\n * @param {undefined | null | FiltersCache} filtersCache\n * @returns {Array<IGatsbyNode> | undefined} Collection of results\n */\nconst filterWithoutSift = (filters, nodeTypeNames, filtersCache) => {\n  if (!filtersCache) {\n    // If no filter cache is passed on, explicitly don't use one\n    return undefined\n  }\n\n  if (filters.length === 0) {\n    // If no filters are given, go through Sift. This does not appear to be\n    // slower than shortcutting it here.\n    return undefined\n  }\n\n  if (\n    filters.some(\n      filter =>\n        filter.type === `query` && !FAST_OPS.includes(filter.query.comparator)\n    )\n  ) {\n    // If there's a filter with non-supported op, stop now.\n    return undefined\n  }\n\n  return runFiltersWithoutSift(filters, nodeTypeNames, filtersCache)\n}\n\n// Not a public API\nexports.filterWithoutSift = filterWithoutSift\n\n/**\n * Use sift to apply filters\n *\n * @param {Array<DbQuery>} filters Resolved\n * @param {boolean} firstOnly\n * @param {Array<string>} nodeTypeNames\n * @param resolvedFields\n * @returns {Array<IGatsbyNode> | undefined | null} Collection of results.\n *   Collection will be limited to 1 if `firstOnly` is true\n */\nconst filterWithSift = (filters, firstOnly, nodeTypeNames, resolvedFields) => {\n  let nodes /*: IGatsbyNode[]*/ = []\n  nodeTypeNames.forEach(typeName => addResolvedNodes(typeName, nodes))\n\n  return runSiftOnNodes(\n    nodes,\n    filters.map(f => dbQueryToSiftQuery(f)),\n    firstOnly,\n    nodeTypeNames,\n    resolvedFields,\n    siftGetNode\n  )\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n *\n * @param {Array<IGatsbyNode>} nodes Should be all nodes of given type(s)\n * @param {Array<DbQuery>} filters Resolved\n * @param {boolean} firstOnly\n * @param {Array<string>} nodeTypeNames\n * @param resolvedFields\n * @param {function(id: string): IGatsbyNode | undefined} getNode\n * @returns {Array<IGatsbyNode> | undefined | null} Collection of results.\n *   Collection will be limited to 1 if `firstOnly` is true\n */\nconst runSiftOnNodes = (\n  nodes,\n  filters,\n  firstOnly,\n  nodeTypeNames,\n  resolvedFields,\n  getNode\n) => {\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(filters)) {\n    const node = getNode(filters[0].id.$eq)\n\n    if (\n      !node ||\n      (node.internal && !nodeTypeNames.includes(node.internal.type))\n    ) {\n      if (firstOnly) {\n        return []\n      }\n      return null\n    }\n\n    return [node]\n  }\n\n  if (firstOnly) {\n    return handleFirst(filters, nodes)\n  } else {\n    return handleMany(filters, nodes)\n  }\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n *\n * @param {Array<IGatsbyNode> | undefined | null} nodes Pre-filtered list of nodes\n * @param {Object | undefined} sort Sorting arguments\n * @param resolvedFields\n * @returns {Array<IGatsbyNode> | undefined | null} Same as input, except sorted\n */\nconst sortNodes = (nodes, sort, resolvedFields, stats) => {\n  if (!sort || nodes?.length <= 1) {\n    return nodes\n  }\n\n  // create functions that return the item to compare on\n  const dottedFields = objectToDottedField(resolvedFields)\n  const dottedFieldKeys = Object.keys(dottedFields)\n  const sortFields = sort.fields.map(field => {\n    if (\n      dottedFields[field] ||\n      dottedFieldKeys.some(key => field.startsWith(key))\n    ) {\n      return `__gatsby_resolved.${field}`\n    } else {\n      return field\n    }\n  })\n  const sortFns = sortFields.map(field => v => getValueAt(v, field))\n  const sortOrder = sort.order.map(order => order.toLowerCase())\n\n  if (stats) {\n    sortFields.forEach(sortField => {\n      stats.uniqueSorts.add(sortField)\n    })\n  }\n\n  return _.orderBy(nodes, sortFns, sortOrder)\n}\n"],"file":"run-sift.js"}