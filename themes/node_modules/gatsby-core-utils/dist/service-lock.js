"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.getServices = exports.getService = exports.createServiceLock = void 0;

var _path = _interopRequireDefault(require("path"));

var _tmp = _interopRequireDefault(require("tmp"));

var _properLockfile = _interopRequireDefault(require("proper-lockfile"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _xdgBasedir = _interopRequireDefault(require("xdg-basedir"));

var _createContentDigest = require("./create-content-digest");

var _ci = require("./ci");

/*
 * Service lock: handles service discovery for Gatsby develop processes
 * The problem:  the develop process starts a proxy server, the actual develop process and a websocket server for communication. The two latter ones have random ports that need to be discovered. We also cannot run multiple of the same site at the same time.
 * The solution: lockfiles! We create a lockfolder in `.config/gatsby/sites/${sitePathHash} and then write a file to that lockfolder for every service with its port.
 *
 * NOTE(@mxstbr): This is NOT EXPORTED from the main index.ts due to this relying on Node.js-specific APIs but core-utils also being used in browser environments. See https://github.com/jprichardson/node-fs-extra/issues/743
 */
const globalConfigPath = _xdgBasedir.default.config || _tmp.default.fileSync().name;

const getLockfileDir = programPath => {
  const hash = (0, _createContentDigest.createContentDigest)(programPath);
  return _path.default.join(globalConfigPath, `gatsby`, `sites`, `${hash}.lock`);
};

const getDataFilePath = (lockfileDir, serviceName) => _path.default.join(lockfileDir, `${serviceName}.lock`);

const memoryServices = {};

const createServiceLock = async (programPath, name, content) => {
  // NOTE(@mxstbr): In CI, we cannot reliably access the global config dir and do not need cross-process coordination anyway
  // so we fall back to storing the services in memory instead!
  if ((0, _ci.isCI)()) {
    if (memoryServices[name]) return null;
    memoryServices[name] = content;
    return async () => {
      delete memoryServices[name];
    };
  }

  const lockfileDir = getLockfileDir(programPath);
  await _fsExtra.default.ensureDir(lockfileDir);

  try {
    const unlock = await _properLockfile.default.lock(lockfileDir, {
      // Use the minimum stale duration
      stale: 5000
    }); // Once the directory for this site is locked, we write a file to the dir with the service metadata

    await _fsExtra.default.writeFile(getDataFilePath(lockfileDir, name), content);
    return unlock;
  } catch (err) {
    return null;
  }
};

exports.createServiceLock = createServiceLock;

const getService = (programPath, name) => {
  if ((0, _ci.isCI)()) return Promise.resolve(memoryServices[name] || null);
  const lockfileDir = getLockfileDir(programPath);

  try {
    return _fsExtra.default.readFile(getDataFilePath(lockfileDir, name), `utf8`);
  } catch (err) {
    return Promise.resolve(null);
  }
};

exports.getService = getService;

const getServices = async programPath => {
  if ((0, _ci.isCI)()) return memoryServices;
  const lockfileDir = getLockfileDir(programPath);
  const files = await _fsExtra.default.readdir(lockfileDir);
  const services = {};
  await Promise.all(files.filter(file => file.endsWith(`.lock`)).map(async file => {
    const service = file.replace(`.lock`, ``);
    services[service] = await getService(programPath, service);
  }));
  return services;
};

exports.getServices = getServices;